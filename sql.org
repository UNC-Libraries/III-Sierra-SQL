#+OPTIONS: ':nil *:t -:t ::nil <:t H:3 \n:nil ^:nil arch:headline
#+OPTIONS: author:t broken-links:mark c:nil creator:nil
#+OPTIONS: d:(not "LOGBOOK") date:nil e:t email:nil f:t inline:t num:nil
#+OPTIONS: p:nil pri:nil prop:nil stat:nil tags:t tasks:nil tex:nil
#+OPTIONS: timestamp:f title:t toc:t todo:f |:t
#+TITLE: Sierra DNA PostgreSQL queries
#+LANGUAGE: en
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+CREATOR: Emacs 25.1.1 (Org mode 9.0.2)

This page contains SQL queries for Sierra and Postgres. The initial set of queries was converted from existing Millennium/Oracle queries that can be found at: [[https://intranet.lib.unc.edu/wikis/staff/index.php/Millennium_SQL_Queries][Millennium SQL Queries (UNC Staff Wiki)]].

* General examples (snippets)

** Make record_num searchable in Sierra
Append 'a'; prepend 'b', 'i', etc.

#+BEGIN_SRC sql
 'b' || record_num || 'a'
 'i' || record_num || 'a'
#+END_SRC
and so on

** Querying by a specific date

#+BEGIN_SRC sql
 WHERE
   record_last_updated_gmt > TO_DATE('2015-08-05', 'YYYY-MM-DD')
#+END_SRC

Postgres date format codes: https://www.techonthenet.com/postgresql/functions/to_date.php

** Querying for a relative time/date (i.e. in the last hour, etc.)
This example will find records updated in the last 60 minutes:

#+BEGIN_SRC sql
 WHERE
   record_last_updated_gmt > (localtimestamp - interval '60 minute')
#+END_SRC

This example will find records updated in the last 1.5 days (36 hours = 2160 minutes):

#+BEGIN_SRC sql
 WHERE
   record_last_updated_gmt > (localtimestamp - interval '36 hour')
#+END_SRC

Postgres time functions and operators: https://www.postgresql.org/docs/9.1/static/functions-datetime.html

** Exclude locations from your query results
 - Add the following to the WHERE section of your query.
 - Used in a query where the set is already narrowed down to only bib records, adding the following would further narrow to exclude any bib with locations beginning with k, no, or w.

#+BEGIN_SRC sql
 and NOT EXISTS (SELECT * from sierra_view.bib_record_location ll
                 WHERE v.record_id = ll.bib_record_id
                    AND (ll.location_code like 'k%'
                         OR ll.location_code like 'no%'
                         OR ll.location_code like 'w%')
                 )
#+END_SRC

** All locations for each bib (string aggregation)
 - Returns record number/key and list of comma separated locations for that bib – collapses multiple rows from the locations table into one row per record number
 - Will be most useful as a join expression, so you can output the locations for some set of bib records

#+BEGIN_SRC sql
 SELECT	bib_record_id,
        STRING_AGG(Trim(trailing FROM location_code), ', ' order by id) AS locations
 FROM	sierra_view.bib_record_location
 WHERE	location_code != 'multi'
 GROUP BY bib_record_id
#+END_SRC

 - Example of use within another query: This would return the record number (with 'a' appended), the bib locations, the marc_tag, indicators, and field value for all 020 fields in all bib records.

#+BEGIN_SRC sql
 select 'b' || b.record_num || 'a' AS bnum,
        bp.material_code,
        locs.locations,
        v.marc_ind1,
        v.marc_ind2,
        v.field_content
 from sierra_view.varfield v
      inner join sierra_view.bib_view b on b.id = v.record_id
      inner join (SELECT bib_record_id,
                      STRING_AGG(Trim(trailing FROM location_code), ', ' order by id) AS locations
               FROM   sierra_view.bib_record_location
               WHERE location_code != 'multi'
               GROUP  BY bib_record_id ) locs
             ON b.id = locs.bib_record_id
#+END_SRC

** Return multiple columns for different var_fields
See [[Home#Bib_500s_and_588s_for_ebooks_without_Law_HSL_or_Wilson_locations_and_not_from_Marcive_or_SerialsSolutions_which_have_title_from_in_the_field | this query below]] for an example of this



* Specific Queries
** Audit ebook 773s
Refer to [https://intranet.lib.unc.edu/wikis/staff/index.php/DATA_Check/clean_up_773_coding_in_collection_records recurring task instructions (STAFF WIKI)] for how these are used
*** Part 1

#+BEGIN_SRC sql
 SELECT
  v.field_content,
  COUNT(v.record_id)     
 FROM
  sierra_view.varfield v
 INNER JOIN
  sierra_view.bib_record b
  ON v.record_id = b.record_id
  AND b.bcode3 NOT IN ('d', 'n', 'c')
 WHERE
  v.varfield_type_code = 'w'
  AND v.marc_tag = '773'
  AND v.field_content LIKE '%(online collection)%'
 GROUP BY v.field_content
 ORDER BY v.field_content ASC;
#+END_SRC

*** Part 2

#+BEGIN_SRC sql
 select 'b' || b.record_num || 'a' AS bnum,
         bp.material_code,
         locs.locations,
         v.marc_ind1,
         v.marc_ind2,
         v.field_content
 from sierra_view.varfield v
    inner join sierra_view.bib_view b ON b.id = v.record_id
    inner join (select bib_record_id,
                STRING_AGG(Trim(trailing FROM location_code), ', ' order by id) AS locations
                FROM   sierra_view.bib_record_location
                WHERE location_code != 'multi'
                GROUP  BY bib_record_id) locs
            ON b.id = locs.bib_record_id
    inner join sierra_view.bib_record_property bp ON b.id = bp.bib_record_id
 where b.bcode3 not in ('d', 'n', 'c')
       and bp.material_code = 'z'
       and v.marc_tag = '773'
       and v.field_content not like '%(online collection)%'
       and v.field_content != '|tOCLC WorldShare Collection Manager managed collection. EbookMain'
       and v.field_content !~ '\|[7db]|\|w\(|\|x\d';
#+END_SRC

** Bib 001s with alphabetic suffixes

#+BEGIN_SRC sql
 select
    v.field_content, bp.material_code
 from
    sierra_view.varfield v, sierra_view.bib_record b,
    sierra_view.bib_record_property bp
 where
    v.marc_tag = '001'
    AND b.bcode3 not in ('n', 'c')
    AND v.field_content ~* '^(\|a)?[0-9]+[a-z]+$'
    AND v.field_content !~* '^(\|a)?[0-9]+(abcc|wcm|dukeup|eeubo|ebr|momw|scidir|spr|wol)$'
    AND bp.bib_record_id = v.record_id
   AND bp.bib_record_id = b.record_id;
 #+END_SRC

 - ~* supplies the case-insensitive parameter

** Bib 856 40s not on e-records
 select 'b' || b.record_num || 'a' as bnum,
      bp.bib_level_code,
      bp.material_code,
      b.bcode3,
      locs.locations,
      l.record_type_code "ldr rec type",
      vform.p23 "008 23",
      vform.p29 "008 29",
      vt.content "GMD",
      vdesc.field_content as "300 description",
      vof.field_content as "other format note",
      v.marc_tag,
      v.marc_ind1,
      v.marc_ind2,
      substring(v.field_content, '\|u[^|]*') "URL",
      substring(v.field_content, '\|y[^|]*') "856y"
 from sierra_view.varfield v
      inner join sierra_view.bib_view b
           on v.record_id = b.id
           and v.marc_tag = '856'
           and v.marc_ind1 = '4'
           and v.marc_ind2 = '0'
       inner join (select bib_record_id, STRING_AGG(Trim(trailing FROM location_code), ', ' order by id) AS locations
       FROM   sierra_view.bib_record_location
               where location_code != 'multi'
                  GROUP  BY bib_record_id) locs
              ON b.id = locs.bib_record_id
      inner join sierra_view.bib_record_property bp
           on b.id = bp.bib_record_id
           and bp.material_code not in ('z', 'w', 's', 'm')
       left outer join sierra_view.leader_field l
           on l.record_id = b.id
       left outer join sierra_view.control_field vform
           on vform.record_id = b.id
           and vform.control_num = '8'
      left outer join sierra_view.subfield vt
           on v.record_id = vt.record_id
           and vt.marc_tag = '245'
           and tag = 'h'
      left outer join sierra_view.varfield vdesc
           on v.record_id = vdesc.record_id
           and vdesc.marc_tag = '300'
      left outer join sierra_view.varfield vof
           on v.record_id = vof.record_id
           and vof.marc_tag = '530'
 where NOT EXISTS (select * from sierra_view.bib_record_location bl
                 WHERE v.record_id = bl.bib_record_id
                 and (bl.location_code like 'e%')
     );

** Bib 856s with invalid subfield tags (indicating probable bad pipe characters in URL)

#+BEGIN_SRC sql
 SELECT 'b' || b.record_num || 'a' AS bnum,
        v.field_content
 FROM   sierra_view.varfield v,  sierra_view.bib_view as b
 WHERE  v.marc_tag = '856'
        AND v.field_content ~ '\|[^abcdfhijklmnopqrstuvwxyz2368]'
        AND b.id = v.record_id;
#+END_SRC

** Bib 856s with more than one |u

#+BEGIN_SRC sql
 SELECT 'b' || b.record_num || 'a' AS bnum,
        v.marc_ind1,
        v.marc_ind2,
        v.field_content
 FROM   sierra_view.varfield v,  sierra_view.bib_view as b
 WHERE  v.marc_tag = '856'
        AND v.field_content ~ '\|u.*\|u'
        AND b.id = v.record_id;
#+END_SRC

** Bibs unsuppressed and HAS cat date, with NO unsuppressed items, holdings, or order records
This query has to exclude e-resource bibs, which by design have all their attached records suppressed. It does this by excluding records with any bib locations starting with e. It is Kristina's understanding that any noheb-type item/holdings/order location should scope within III to include a bib location starting with e. 

#+BEGIN_SRC sql
 SELECT 'b' || b.record_num || 'a' AS bib_rec_key,
        locs.locations,
       To_char(b.record_creation_date_gmt, 'YYYY-MM-DD') AS "created date",
       bp.material_code
 FROM   sierra_view.bib_view b
        inner join (SELECT bib_record_id, STRING_AGG(Trim(trailing FROM location_code), ', ' order by id) AS locations
                    FROM   sierra_view.bib_record_location
                    WHERE location_code != 'multi'
                    GROUP  BY bib_record_id) locs
               ON b.id = locs.bib_record_id
        INNER JOIN sierra_view.bib_record_property bp on bp.bib_record_id = b.id
 WHERE  b.bcode3 NOT IN ( 'd', 'n', 'c' )
       AND b.cataloging_date_gmt IS NOT NULL
        AND NOT EXISTS (SELECT *
                        FROM sierra_view.bib_record_item_record_link lri
                        INNER JOIN sierra_view.item_record i
                        ON lri.item_record_id = i.id
                        WHERE b.id = lri.bib_record_id
                          AND i.icode2 <> 'n')
        AND NOT EXISTS (SELECT *
                        FROM sierra_view.bib_record_holding_record_link lrh
                        INNER JOIN sierra_view.holding_record h
                        ON lrh.holding_record_id = h.id
                        WHERE b.id = lrh.bib_record_id
                          AND h.is_suppressed <> 't')
        AND NOT EXISTS (SELECT *
                        FROM sierra_view.bib_record_order_record_link lro
                        INNER JOIN sierra_view.order_record o
                        ON lro.order_record_id = o.id
                        WHERE b.id = lro.bib_record_id
                          AND o.is_suppressed <> 't')
       AND NOT EXISTS (SELECT *
                       FROM   sierra_view.bib_record_location bl
                       WHERE  b.id = bl.bib_record_id
                              AND bl.location_code LIKE 'e%');
#+END_SRC

** Bibs unsuppressed and NO cat date, with NO unsuppressed items, holdings, or order records

#+BEGIN_SRC sql
 SELECT 'b' || b.record_num || 'a' as bib_rec_key,
        locs.locations,
       to_char(b.record_creation_date_gmt, 'YYYY-MM-DD') as "created date"
 FROM sierra_view.bib_view b
        inner join (select bib_record_id, STRING_AGG(Trim(trailing FROM location_code), ', ' order by id) AS locations
                FROM   sierra_view.bib_record_location
                where location_code != 'multi'
                   GROUP  BY bib_record_id) locs
               ON b.id = locs.bib_record_id
 WHERE b.bcode3 NOT IN ('d', 'n', 'c')
 AND cataloging_date_gmt is NULL
 AND NOT EXISTS (SELECT *
                FROM sierra_view.bib_record_item_record_link lri
                INNER JOIN sierra_view.item_record i
                ON lri.item_record_id = i.id
                WHERE b.id = lri.bib_record_id
                  AND i.icode2 <> 'n')
 AND NOT EXISTS (SELECT *
                FROM sierra_view.bib_record_holding_record_link lrh
                INNER JOIN sierra_view.holding_record h
                ON lrh.holding_record_id = h.id
                WHERE b.id = lrh.bib_record_id
                  AND h.is_suppressed <> 't')
 AND NOT EXISTS (SELECT *
                FROM sierra_view.bib_record_order_record_link lro
                INNER JOIN sierra_view.order_record o
                ON lro.order_record_id = o.id
                WHERE b.id = lro.bib_record_id
                  AND o.is_suppressed <> 't')
                  ;
#+END_SRC

** Items linked to more than one bib record, where icode2 is not set as linked or bound with – includes suppressed items (icode2 = n) that lack internal note about linked records <code>(Wanda)</code>

#+BEGIN_SRC sql
 SELECT
  ibar.inum as item_rec_num,
  ibar.lbibs as linked_bib_count,
  bibs.bnums as linked_to_bibs,
  ibar.icode2,
  ibar.item_status_code,
  ibar.location_code,
  ibar.barcode
 FROM
   -- IBAR -- Item fixed field data with barcodes where assigned
   (SELECT
    ifix.id,
    ifix.inum,
    ifix.lbibs,
    ifix.icode2,
    ifix.item_status_code,
    ifix.location_code,
    bc.barcode 
   FROM
     -- IFIX
     -- All the fixed field data for relevant items
     (SELECT
      ict.id,
      idata.inum,
      ict.lbibs,
      idata.icode2,
      idata.item_status_code,
      idata.location_code
     FROM
       -- ICT
       -- The set of items attached to more than one bib, with icode2 not l or b,
       -- with count of bibs to which item is attached (lbibs)
       (SELECT
        alli.id,
        linkct.lbibs     
       FROM
         -- ALLI
         -- Item records where icode2 is not l (linked) or b (bound with)
         (SELECT
          id
         FROM
          sierra_view.item_view
         WHERE
          icode2 NOT IN ('b', 'l') ) alli
         -- END ALLI
       INNER JOIN
         -- LINKCT
         -- Item record number with count of linked bibs, where count is
         -- the same regardless of directionality of query, and count is > 1
         (SELECT
            item_record_id,
            COUNT(item_record_id) AS lbibs
           FROM
            sierra_view.bib_record_item_record_link
           WHERE
            bib_record_id is not null
           GROUP BY
            item_record_id) linkct
         -- END LINKCT
       ON alli.id = linkct.item_record_id
       WHERE linkct.lbibs > 1 ) ict 
       -- END ICT
     INNER JOIN
       -- IDATA - other fixed field item data from item2base
       (SELECT
        id,
        'i' || record_num || 'a' AS inum,
        icode2,
        item_status_code,
        location_code
       FROM
        sierra_view.item_view) idata
       -- END IDATA
     ON ict.id = idata.id) ifix
     --END IFIX
   LEFT OUTER JOIN
     -- BC - barcode data to merge in
     -- don't know the results will change in a meaningful way if barcode is pulled from item_view rather than this join -jm
     (SELECT
      record_id,
      MIN(field_content) AS barcode
     FROM
      sierra_view.varfield
     WHERE
      varfield_type_code = 'b'
      GROUP BY record_id) bc
     -- END BC
   ON ifix.id = bc.record_id) ibar
   -- END IBAR
 LEFT OUTER JOIN
   -- LNOTE - get linked item note where assigned
   (SELECT
    record_id,
    MIN(field_content) AS linknote
   FROM
    sierra_view.varfield
   WHERE
    varfield_type_code = 'x'
    AND field_content LIKE 'Item record linked to%'
    GROUP BY record_id) lnote
 -- END LNOTE
 ON ibar.id = lnote.record_id
 INNER JOIN (SELECT item_record_id,
                STRING_AGG(Trim(trailing FROM cast(bib_record_id as varchar)), ', ' order by id) AS bnums
         FROM   sierra_view.bib_record_item_record_link
         WHERE  bib_record_id is not NULL
         GROUP  BY item_record_id) bibs
     ON ibar.id = bibs.item_record_id       
 WHERE
 ibar.icode2 != 'n'
 OR (ibar.icode2 = 'n' AND lnote.linknote is null)
 ;
#+END_SRC

** Bibs with more than one instance of a given field
Query now depends on whether field is a control field or variable field.
*** control field

#+BEGIN_SRC sql
 SELECT
    'b' || b.record_num as bnum
 FROM
    sierra_view.control_field c, sierra_view.bib_view b
 WHERE
    c.control_num = '8'
    AND c.record_id = b.id
 GROUP BY
   bnum HAVING COUNT(*) > 1;
#+END_SRC

*** variable field

#+BEGIN_SRC sql
 SELECT
    'b' || b.record_num as bnum
 FROM
    sierra_view.varfield v, sierra_view.bib_view b
 WHERE
    v.marc_tag = '856'
    AND v.record_id = b.id
 GROUP BY
    bnum HAVING COUNT(*) > 1;
#+END_SRC

** Items (non-e-format, based on location code) attached to e-bibs (based on material_code / mat_type)

#+BEGIN_SRC sql
 select i.location_code, 'i' || i.record_num as inum, 'b' || b.record_num as bnum, br.material_code, i.itype_code_num as itemType, i.item_status_code as itemStatus
 from sierra_view.item_view i, sierra_view.bib_view b, sierra_view.bib_record_property br, sierra_view.bib_record_item_record_link L
 where br.material_code in ('s', 'w', 'z')
 and i.location_code not in ('dcpfi','dcya','dcyea','dcyef','dcyfa','eb','ebna','ebnb','ebz','ed','edas','er','erda','erdb','erra','errd','erri','erri@','errs','errw','estr','erz','hhya','hhyb','jjya','kwer','kwer2','nohe','noheb','uldah','wbcc','wbpab','wbpad','xcac','xcad','ydya')
 and L.item_record_id = i.id
 and L.bib_record_id = b.id
 and br.bib_record_id = b.id;
#+END_SRC

** Bibs with holdings record(s) for a location but no item record(s) for that location

#+BEGIN_SRC sql
 (select
   'b' || b.record_num AS bnum
 from
   sierra_view.bib_record_holding_record_link Lr
   inner join sierra_view.holding_record_location h on
     Lr.holding_record_id = h.holding_record_id
    inner join sierra_view.bib_view b on
     Lr.bib_record_id = b.id
 where
   h.location_code like 'xc%')
 EXCEPT
 (select
   'b' || b.record_num AS bnum
 from
   sierra_view.bib_record_item_record_link Lrr
   inner join sierra_view.item_record i on
     Lrr.item_record_id = i.record_id
    inner join sierra_view.bib_view b on
     Lrr.bib_record_id = b.id
 where
     i.location_code like 'xc%')
 ;
#+END_SRC

** Bibs unsuppressed - Count of

#+BEGIN_SRC sql
 select count(b.id)
 from sierra_view.bib_view b
 where b.bcode3 not in ('d', 'n', 'c');
 #+END_SRC

 - Using bib_record (and .record_id) rather than bib_view (and .id) reporting more accurate results due to presumed sync issues prior to Sierra migration completion

** Items in a location, returning input for Endeca args_extract

#+BEGIN_SRC sql
 SELECT DISTINCT 'b' || b.record_num as bnum,
                 to_char(b.cataloging_date_gmt, 'YYYYMMDD'),
                 br.material_code
 FROM
 sierra_view.item_view i, sierra_view.bib_view b, sierra_view.bib_record_property br, sierra_view.bib_record_item_record_link L
 WHERE
         i.location_code LIKE 'yb%'
         AND b.bcode3 NOT IN ('n', 'c', 'd')
         AND b.id = br.bib_record_id
         AND b.id = L.bib_record_id
         AND i.id = L.item_record_id;
#+END_SRC

** Items last checked in within the last 18 hours, NOT in reserve locations (remove NOT to get only those in reserve locations)

#+BEGIN_SRC sql
 SELECT 'i' || i.record_num AS inum,
         i.item_status_code,
         TO_CHAR(i.last_checkin_gmt, 'MM/DD/YYYY HH24:MI')   AS chkin,
         date_part('day', (localtimestamp - i.last_checkin_gmt)) AS days_since_chkin,
         i.location_code,
         TO_CHAR(i.due_gmt, 'MM/DD/YYYY HH24:MI')    AS due,
         TO_CHAR(i.record_creation_date_gmt, 'MM/DD/YYYY')   AS created
 FROM    (sierra_view.item_view iv LEFT JOIN sierra_view.checkout c ON
         iv.id = c.item_record_id) i
 WHERE   i.last_checkin_gmt > (localtimestamp - interval '18 hour')
         AND i.icode2 != 'n'
         AND i.location_code !~* '^(aaba|bbb|ccb|ggb|kres|llb|mmb|nohv|rrb|ssb|ub|ulba|wcb|xcca|ydb).*$'
 ORDER BY i.last_checkin_gmt DESC
 ;
#+END_SRC

** Items recently checked out (last hour)

#+BEGIN_SRC sql
 SELECT
     to_char(c.checkout_gmt, 'MM/DD/YYYY HH24:MI') as checkedout,
     'b' || v.record_num AS bnum,
     v.field_content
 from sierra_view.checkout c, sierra_view.varfield_view v, sierra_view.bib_record_item_record_link L
 where   c.checkout_gmt > (localtimestamp - interval '1 hour')
         AND c.item_record_id = L.item_record_id
         AND L.bib_record_id = v.record_id
         AND v.marc_tag = '245'
     order by c.checkout_gmt DESC;
#+END_SRC

** Items placed on hold in the last 24 hours

#+BEGIN_SRC sql
 SELECT 'i' || i.record_num as inum, TO_CHAR(h.placed_gmt, 'YYYY/MM/DD HH24:MI:SS'), 'b' || b.record_num as bib, v.field_content as barcode, i.location_code
         from sierra_view.hold h
   INNER JOIN sierra_view.bib_record_item_record_link l ON h.record_id = l.item_record_id
   INNER JOIN sierra_view.bib_view b ON b.id = l.bib_record_id
   INNER JOIN sierra_view.varfield v ON v.record_id = h.record_id
     AND v.varfield_type_code = 'b'
   INNER JOIN sierra_view.item_view i ON h.record_id = i.id
         where h.placed_gmt >= (localtimestamp - interval '24 hour')
         order by h.placed_gmt;
#+END_SRC

** Items that have never circulated (specifically, that have null LCHKIN fields)

#+BEGIN_SRC sql
 SELECT
     'i' || i.record_num || 'a' AS inum
 FROM
     sierra_view.varfield v, sierra_view.item_view  i
 WHERE
     v.varfield_type_code = 'b'
     AND v.record_type_code = 'i'
     AND v.record_id = i.id
 GROUP BY
     i.record_num HAVING COUNT(*) > 1;
#+END_SRC

** Items with more than one instance of a given field
This example finds records with more than one barcode field:

#+BEGIN_SRC sql
 SELECT
     'i' || i.record_num || 'a' AS inum
 FROM
     sierra_view.varfield v, sierra_view.item_view  i
 WHERE
     v.varfield_type_code = 'b'
     AND v.record_type_code = 'i'
     AND v.record_id = i.id
 GROUP BY
     i.record_num HAVING COUNT(*) > 1;
#+END_SRC

** Items with more than one instance of a given field, listing the values of that field

#+BEGIN_SRC sql
 select 'i' || vf.record_num || 'a' AS "item_num",
     vf.varfield_type_code AS "field type",
     vf.occ_num AS "field_order",
     vf.field_content AS "call_number_field_value"
 FROM sierra_view.varfield_view vf
 INNER JOIN (select vs.record_id
 from sierra_view.varfield_view vs
 where vs.record_type_code = 'i'
 and vs.varfield_type_code = 'c'
 group by vs.record_id
 having count(vs.record_id) > 1) vi
 ON vf.record_id = vi.record_id
 WHERE vf.varfield_type_code = 'c'
 order by vf.record_id ASC;
#+END_SRC

** Count occurrence of MARC tags across the catalog

#+BEGIN_SRC sql
 select
     v.marc_tag, count(v.marc_tag)
 from
     sierra_view.varfield v, sierra_view.bib_record b
 where
     b.bcode3 not in ('d', 'n', 'c')
     AND b.record_id = v.record_id
 group by v.marc_tag;
#+END_SRC

** List bnums containing 856 |u that is longer than 300 characters, ordered by |u length

#+BEGIN_SRC sql
 SELECT sq1.bnum, sq1.URLlength
 FROM (SELECT ('b' || b.record_num) as bnum,
         CHAR_LENGTH(REGEXP_REPLACE(v.field_content, '^(.*\|u)([^|]+)(.*)', '\2')) AS URLlength
 FROM sierra_view.varfield v, sierra_view.bib_view b
 WHERE
         v.marc_tag = '856'
         AND b.id = v.record_id) sq1
 WHERE sq1.URLlength > 300
 order by sq1.URLlength DESC;
#+END_SRC

** Bib 020s from records where any 020 contains more than one |a
Returns ALL 020s from any record with a repeated 020|a

#+BEGIN_SRC sql
 SELECT 'b' || relbibs.record_num || 'a' AS bnum,
        allbibs.varfield_type_code,
        allbibs.marc_tag,
        allbibs.marc_ind1,
        allbibs.marc_ind2,
        allbibs.field_content
 FROM
   (SELECT v.record_id,
          v.varfield_type_code,
          v.marc_tag,
          v.marc_ind1,
          v.marc_ind2,
          v.field_content
   FROM sierra_view.varfield v, sierra_view.bib_record b
   WHERE v.record_id = b.record_id
         AND marc_tag = '020') allbibs
 INNER JOIN
     (SELECT vv.record_id, bb.record_num
     FROM sierra_view.varfield vv, sierra_view.bib_view bb
     WHERE   marc_tag = '020'
             AND vv.record_id = bb.id
             AND field_content ~ '\|a.*\|a') relbibs
 ON allbibs.record_id = relbibs.record_id
 ORDER by bnum ASC;
#+END_SRC

** Bib variable fields that are too long (primarily used to identify long notes fields that need to be split up for Endeca ingest)
*** based on char length

#+BEGIN_SRC sql
 select
 'b' || b.record_num as bnum, octet_length(v.field_content) as octet_length, length(v.field_content) as char_length, *
 from
     sierra_view.varfield v, sierra_view.bib_view as b
 WHERE 
     length(v.field_content) >= 2985
    AND b.id = v.record_id;
 #+END_SRC

*** based on octet length

#+BEGIN_SRC sql
 select
 'b' || b.record_num as bnum, octet_length(v.field_content) as octet_length, length(v.field_content) as char_length, *
 from
     sierra_view.varfield v, sierra_view.bib_view as b
 WHERE 
     octet_length(v.field_content) >= 3950
     AND b.id = v.record_id
 ;
#+END_SRC
 - measuring the octet length directly cuts the number of results down to ~680 from ~2400, and should still identify fields with a length of >4k bytes. Perhaps a useful alternative, perhaps not.

** Items with barcodes that do not match known valid barcode patterns

#+BEGIN_SRC sql
 select 'i' || i.record_num AS inum,
        i.location_code,
        i.item_status_code,
        r.record_last_updated_gmt,
        vc.field_content AS "callnumber",
        vv.field_content AS "volume",
        v.field_content AS "barcode"
 from sierra_view.varfield v
 left join sierra_view.item_view i
 on v.record_id = i.id 
 left outer join sierra_view.varfield vc on v.record_id = vc.record_id and vc.varfield_type_code = 'c'
 left outer join sierra_view.varfield vv on v.record_id = vv.record_id and vv.varfield_type_code = 'v'
 left join sierra_view.record_metadata r on i.id = r.id
 where v.varfield_type_code = 'b'
 and NOT i.item_status_code = 'w'
 and NOT v.field_content ~ '^0\d{10}$' /* AAL Mill normal 11-char */
 and NOT v.field_content ~ '^1\d{10}$' /* AAL Mill on-the-fly 11-char */
 and NOT v.field_content ~ '^H[ABX][A-Z]{2}-\d{4}-\d{5}$' /* AAL DRA autogenerated placeholder */
 and NOT v.field_content ~ '^L[AB][A-Z]{2}-\d{4}-\d{5}$' /* AAL DRA loaned */
 and NOT v.field_content ~ '^L\d{8}[A-Z]$' /* LAW Mill 10-char with ending letter */
 and NOT v.field_content ~ '^H\d{8}[A-Z]$' /* HSL Mill 10-char with ending letter */
 and NOT v.field_content ~ '^CPC\d{8}$' /* Carolina Pop Ctr Mill*/
 and NOT v.field_content ~ '^PL\d{8}$' /* Park Library Mill*/
 and NOT v.field_content ~ '^9\d{10}$' /* Hwy Saftey Mill*/
 and NOT v.field_content ~ '^\d{8}$' /* ESM PRR serials barcode (bnum without the b on the front) */
 and NOT v.field_content ~ '^HAYA-\d{4}-\d{6}$' /* Gov doc serial items never inventoried/barcoded by staff */
 /* The following are NOT in Wanda's list of valid patterns, but there are a lot of them */
 and NOT v.field_content ~ '^L\d{9}$' /* LAW Mill 10-char, no ending letter: L003987970 */
 and NOT v.field_content ~ '^L\d{8}(-|[%.$+`])$' /* LAW Mill 10-char, ending punctuation: 
   L00399687% L00399456- L00399457. L00399459$ L00399479+ */
 and NOT v.field_content ~ '^H\d{8}(-|[%.$+`])$' /* HSL Mill 10-char, ending punctuation: 
   H00098769$ H00467879+ H00158797. H00129996- */
 and NOT v.field_content ~ '^L\d{8}$' /* LAW Mill 9-char, no ending letter: L00399485 */
 and NOT v.field_content ~ '^H\d{8}$' /* HSL Mill 9-char, no ending letter: H00099758 */
 and NOT v.field_content ~ '^H\d{9}$' /* HSL Mill 10-char, no ending letter: H001130005 */
 and NOT v.field_content ~ '^[01]\d{10}0+$' /* AAL Mill 11-char followed by addtl 0s: 000030389101 */
 and NOT v.field_content ~ '^[01]\d{11}$' /* AAL Mill 12-char: 000455125050 */
 and NOT v.field_content ~ '^[0]\d{9}$' /* AAL Mill normal 10-char: 0000337460 */
 and NOT v.field_content ~ '^[0]\d{8}$' /* AAL Mill normal 9-char: 000362186 */
 and NOT v.field_content ~ '^[01]\d{10}(-|[%.$+`])$' /* AAL Mill 11-char followed by punctuation: 
   00046484641- 00038189888` */
;
#+END_SRC

** Bib 590s (all) from only records where a 590 has a repeated $a and 001 beginning with sse
Use as pattern for any time you need to get all occurrences of a field from only those records where at least one instance of that field meets criteria

#+BEGIN_SRC sql
 SELECT 'b' || b.record_num || 'a' as bnum,
         v.field_content as note
 FROM
     sierra_view.varfield v
 INNER JOIN sierra_view.bib_view b
     ON b.id = v.record_id
 WHERE v.marc_tag = '590'
     AND b.bcode3 NOT IN ('d', 'n', 'c')
     AND EXISTS (select * from sierra_view.varfield vo
                 where v.record_id = vo.record_id
                 and vo.marc_tag = '001'
                 and vo.field_content like 'sse%')
     AND EXISTS (select * from sierra_view.varfield vd
                 where v.record_id = vd.record_id
                 and vd.marc_tag = '590'
                 and vd.field_content ~ '\|a.*\|a')
                 ;
#+END_SRC

** Bib 500s and 588s for ebooks without Law, HSL, or Wilson locations, and not from Marcive or SerialsSolutions, which have 'title from' in the field
<div id="multiple_varfields_query_example"></div>

#+BEGIN_SRC sql
 select 'b' || b.record_num || 'a' AS bnum,
        vc.field_content as coll,
        locs.locations,
        v.marc_tag,
        v.marc_ind1,
        v.marc_ind2,
        v.field_content
 from sierra_view.varfield v
 inner join sierra_view.bib_view b on v.record_id = b.id
 inner join sierra_view.bib_record_property bp on v.record_id = bp.bib_record_id and bp.material_code = 'z'
         inner join (select bib_record_id, STRING_AGG(Trim(trailing FROM location_code), ', ' order by id) AS locations
         FROM   sierra_view.bib_record_location
                 where location_code != 'multi'
                    GROUP  BY bib_record_id) locs
                ON b.id = locs.bib_record_id
 left outer join sierra_view.varfield vg on v.record_id = vg.record_id and vg.marc_tag = '040'
 left outer join sierra_view.varfield vc on v.record_id = vc.record_id and vc.marc_tag = '773' and vc.field_content like '%online collection%'
 where
   v.marc_tag in ('500', '588')
   and v.field_content like '%title from%'
   and vg.field_content not like '%WaSeSS%'
   and vg.field_content not like '%GPO%'
   and b.cataloging_date_gmt is not null
   and NOT EXISTS (select * from sierra_view.bib_record_location ll
                   WHERE v.record_id = ll.bib_record_id
                   and (ll.location_code like 'k%'
            or ll.location_code like 'no%'
            or ll.location_code like 'w%')
       )
   ;
#+END_SRC

** Bib 008s - list of unique language codes used in catalog

#+BEGIN_SRC sql
 select
  DISTINCT(concat(c.p35, c.p36, c.p37)) as lang_code
 from
  sierra_view.control_field c, sierra_view.bib_record b
 where c.control_num = '8'
     AND b.record_id = c.record_id
 ;
 #+END_SRC

 - Using concat(n1, n2, n3) rather than n1 || n2 || n3 preserves spaces (i.e. does not collapse "n e" into "ne")

** Get Endeca bnum input for extract for list of bibs

#+BEGIN_SRC sql
 select 'b' || record_num AS bnum,
        to_char(cataloging_date_gmt, 'YYYYMMDD'),
        bcode2
 from sierra_view.bib_view
 where record_num in ('4895022', '5191508', '6227008');
#+END_SRC


** Get all ISBNs from selected collections (e.g. for JSTOR DDA)

#+BEGIN_SRC sql
 select 'b' || b.record_num || 'a' as bnum, v.field_content as collection, vi.field_content as isbn, vt.field_content as title
 from sierra_view.varfield v
 INNER JOIN sierra_view.varfield vi on vi.record_id = v.record_id and vi.marc_tag = '020'
 LEFT OUTER JOIN sierra_view.varfield vt on vt.record_id = v.record_id and vt.marc_tag = '245'
 INNER JOIN sierra_view.bib_view b on v.record_id = b.id 
 where v.marc_tag = '773'
      and (v.field_content like '%Ebscohost ebooks (online collection). HSL Via YBP%'
     or v.field_content like '%|tEbrary perpetual access (online collection). UNL title-by-title%'
     or v.field_content like '%|tEbrary perpetual access (online collection). UNL via YBP%')
#+END_SRC


** Get bibs with cat date in the future
Adjust date as needed:

#+BEGIN_SRC sql
 SELECT 'b' || b.record_num || 'a' as bib_rec_key,
        locs.locations,
        to_char(b.cataloging_date_gmt, 'YYYY-MM-DD') as "cat_date",
        to_char(b.record_creation_date_gmt, 'YYYY-MM-DD') as "created", 
        to_char(r.record_last_updated_gmt, 'YYYY-MM-DD') as "updated"		
 FROM sierra_view.bib_view b
        inner join (select bib_record_id, STRING_AGG(Trim(trailing FROM location_code), ', ' order by id) AS locations
                FROM   sierra_view.bib_record_location
                where location_code != 'multi'
                   GROUP  BY bib_record_id) locs
               ON b.id = locs.bib_record_id,
       sierra_view.record_metadata r
 WHERE b.cataloging_date_gmt > '2017-01-26'::date
       and r.id = b.id
#+END_SRC

** Holdings record 866 fields (iii field tag = h) where the holdings record has more than 2 such 866 fields

#+BEGIN_SRC sql
 SELECT
   *
 FROM
   sierra_view.varfield_view v
 INNER JOIN(
   SELECT
     vv.record_num
   FROM
     sierra_view.varfield_view vv
   WHERE
     vv.record_type_code = 'c'
   AND vv.varfield_type_code = 'h'
   AND vv.marc_tag = '866'
   GROUP BY
     vv.record_num
   HAVING
     COUNT(*)> 2
 )vvv ON vvv.record_num = v.record_num
 WHERE
   v.record_type_code = 'c'
 AND v.varfield_type_code = 'h'
 AND v.marc_tag = '866'
 ORDER BY
   v.record_num,
   v.occ_num ASC;
#+END_SRC

** Holdings record numbers where holdings record is attached to a serial bib, is unsuppressed, contains more than one (h)863 field, and contains NO (h)866 field

#+BEGIN_SRC sql
 SELECT
   'c' || hr.record_num
 FROM
   sierra_view.holding_view hr
 INNER JOIN sierra_view.bib_record_holding_record_link bhl ON hr. ID = bhl.holding_record_id
 INNER JOIN sierra_view.leader_field ldr ON bhl.bib_record_id = ldr.record_id
 AND ldr.bib_level_code = 's'
 INNER JOIN sierra_view.varfield vf ON hr. ID = vf.record_id
 AND vf.varfield_type_code = 'h'
 AND vf.marc_tag = '863'
 AND NOT EXISTS(
   SELECT
     *
   FROM
     sierra_view.varfield v2
   WHERE
     v2.record_id = vf.record_id
   AND v2.varfield_type_code = 'h'
   AND v2.marc_tag = '866'
 )
 WHERE
   hr.is_suppressed = 'f'
 INTERSECT
   SELECT
     'c' || vv.record_num
   FROM
     sierra_view.varfield_view vv
   WHERE
     vv.record_type_code = 'c'
   AND vv.varfield_type_code = 'h'
   AND vv.marc_tag = '863'
   GROUP BY
     vv.record_num
   HAVING
     COUNT(*)> 1 
#+END_SRC
